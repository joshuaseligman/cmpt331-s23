\documentclass[letterpaper, 10pt, DIV=13]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath, amsfonts, amsthm, xfrac}
\usepackage{listings}
\usepackage{color}
\usepackage{longtable}

\numberwithin{equation}{section}
\numberwithin{figure}{section}
\numberwithin{table}{section}

\usepackage{sectsty}
\allsectionsfont{\normalfont\scshape} % Make all section titles in default font and small caps.

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers

\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer

\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt}

% Colors and lstset for syntax highlighting from https://www.overleaf.com/latex/examples/syntax-highlighting-in-latex-with-the-listings-package/jxnppmxxvsvk
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}

\setlength\parindent{0pt}
\pagenumbering{gobble}

\title {
	\normalfont
	\huge{Programming in the Past} \\
	\vspace{10pt}
	\large{CMPT 331 - Spring 2023 | Dr. Labouseur}
}

\author{\normalfont Josh Seligman | joshua.seligman1@marist.edu}

\pagenumbering{arabic}
\begin{document}
\maketitle

\section{Log}
\subsection{Predicton}
I am predicting that it will take me around \textbf{20 hours (average of 4 hours per programming language)} for me to learn Fortran, COBOL, BASIC, Pascal, and Scala and build a Caesar cipher in each language. This is an extremely rough estimate as I have never used any of these programming languages before and will have to learn each of them starting with "hello world." I am sure that I will have moments of staring at my computer screen for extended periods of time due to a weird nuance or gimmick in at least one of these programming languages that is not common in more modern languages. However, despite my lack of familiarity with these languages, I am hoping that there will be some nice similarities between them, so my approach to writing the Caesar cipher does not drastically change between them, and each implementation can easily be compared to each other on an even playing field.

\subsection{Progress Log}
\begin{center}
	\begin{longtable}{|p{1in}|p{1in}|p{4in}|}
		\hline
		Date & Hours Spent & Tasks / Accomplishments / Issues / Thoughts
		\\
		\hline
		January 18 & 3 hours & I built the entire Caesar cipher in Fortran, which was a bit frustrating but not the worst thing in the world. The language had some weird quirks, but was doable considering that it only took me a few hours.
		\\
		\hline
		January 19 & 3 hours & I started working on the Caesar cipher in COBOL. This has been exponentially more difficult than Fortran as some of the language's tiny details made me stare at a computer screen for hours without any resources because there were no error messages or warnings.
		\\
		\hline
		January 20 & 0.25 hours & I modified my Fortran implementation to account for negative shift amounts and shift amounts greater than 26. \\
		\hline
		January 20 & 1.5 hours & I finished writing the Caesar cipher in COBOL and dealt with more of COBOL's small nuances that did not provide error messages or warnings. Luckily, it did not take me nearly as long to find the issues today as it did for me yesterday.
		\\
		\hline
		January 21 & 1.5 hours & I wrote the Caesar cipher in BASIC without much trouble. The code was quite simple, and I enjoyed my time writing the BASIC program.
		\\
		\hline
		January 26 & 0.75 hours & I wrote the Caesar cipher in Pascal with even less trouble than BASIC. I was genuinely surprised by how quickly I completed the Caesar cipher in Pascal and found the language to be really nice and better than some modern languages.
		\\
		\hline
		January 27 & 0.75 hours & I wrote the Caesar cipher in Scala, which was unsurprisingly almost identical to how it would have been written in Java. Scala was a bit frustrating at times because of its quirks to try to simplify Java, but its tooling made my experience better compared to some of the older languages.
		\\
		\hline
	\end{longtable}
\end{center}

\subsection{Final Results and Analysis}
Overall, this assignment took me 10.75 hours to complete, which is about half the time I initially expected. Although I was on pace for 20 hours after Fortran and COBOL, the time required for me to write the Caesar cipher in BASIC, Pascal, and Scala was much shorter than originally anticipated. I initially predicted about 20 hours because I did not know what to expect from the older programming languages and was unsure how long it would take for me to learn enough of each language to put together the respective programs. Furthermore, the results from Google searches were much more detailed and useful for the last 3 languages because they are not as old and have some good online resources that demonstrate the basics of the languages. Also, since they are newer, BASIC, Pascal, and Scala all have grammars that are much closer to other popular programming languages today, so more similarities were able to be recognized and taken advantage of. On the other hand, since there is no language today like COBOL, it is in a league of its own and had to be figured out in its entirety with no assumptions of similarities to other languages. Lastly, as described in my prediction, I wanted the solutions to be as close to each other as possible. Thus, I did not try to do anything crazy with the solutions and kept it simple throughout. In other words, once I wrote the Caesar cipher in Fortran, the assignment became a task of trying to translate the Fortran code into other languages rather than trying to create a new solution from scratch 5 times.

\section{Commentary}
\subsection{Fortran}
\subsubsection{My Thoughts}
Building the Caesar cipher in Fortran was a challenging experience due to its strict rules regarding code organization and how functions and subroutines work. First, regarding code organization, I did not like having to declare all used variables at the top of a subroutine. In many other languages, the purpose of variables can oftentimes be inferred by the location in which they are declared. For instance, a variable declared by a loop often means it will have an important role in the loop, usually as a loop increment variable. However, in Fortran, since the variables were declared at the top of each subroutine and program, the readability of the language is hurt because the variables are all clumped together, and the language is tougher to write because you have to be careful in making sure that comments are written to explain what each variable will be used for. In the end, this organization did clean up the rest of the subroutine, but I would have rather declared the variables in more logical spots to go along with the flow of the program.
\\ \\
Another issue that I had with Fortran was with functions and returning values. I initially wanted to use functions to take in the original string and return the output string for encrypt and decrypt. However, functions and character objects were really not working nice as I received a bunch of errors, for which Google searches were not able to help me as the language has not been widely used since the inception of the internet. Some of these errors included but were not limited to an "entity with assumed character length at (1) must be a dummy argument or a PARAMETER" and functions that were explicitly marked to return a character (string) were returning a REAL and caused type mismatches at compile time. In the end, the best resource on the internet was the quick start guide on Fortran's official website, whose advanced examples provided me with some inspiration to use a subroutine and pass in the variable that would be modified and used as an output. Additionally, I wanted to make the function/subroutine support characters of an unknown length to work with all possible inputs. However, despite a lot of forums online having examples with this as the situation, the code just never compiled or worked for me. Therefore, I chose to have one of the parameters of my subroutines to be the length of the string, so the variable declarations at the top of the subroutine would be able to provide a known length.
\\ \\
Overall, aside from the variables being declared up top, Fortran is quite a clean programming language in terms of readability as a lot of the control structures are similar to those in more modern languages. However, the lack of clarity for how functions work with strings is extremely frustrating and significantly hurts the writability of Fortran as I had to find a way to finesse a solution using subroutines and pass in the output variable, even though I would have preferred to have better organized code that returns a result from a function.

\subsubsection{Google Search History}

\begin{itemize}
	\item fortran hello world
	\item function in fortran
	\item string type in fortran
	\item get length of string in fortran
	\item Entity at (1) has a deferred type parameter and requires either the POINTER or ALLOCATABLE attribute
	\item pass in character to a function fortran
	\item Entity with assumed character length at (1) must be a dummy argument or a PARAMETER
	\item return string from function fortran
	\item iterate through characters in a string fortran
	\item fortran print string to include value of variable
	\item fortran mod
\end{itemize}

\subsubsection{Code and Tests}
\lstinputlisting[caption = Caesar Cipher (Fortran), language = Fortran]{./../fortran/caesar.f90}
\begin{lstlisting}[frame=single, caption = Fortran Output]  
> gfortran caesar.f90 -o caesar
> ./caesar
 Alan tests:
 BPQA QA I BMAB ABZQVO NZWU ITIV
 THIS IS A TEST STRING FROM ALAN
Caesar 26: HAL
Caesar 25: GZK
Caesar 24: FYJ
Caesar 23: EXI
Caesar 22: DWH
Caesar 21: CVG
Caesar 20: BUF
Caesar 19: ATE
Caesar 18: ZSD
Caesar 17: YRC
Caesar 16: XQB
Caesar 15: WPA
Caesar 14: VOZ
Caesar 13: UNY
Caesar 12: TMX
Caesar 11: SLW
Caesar 10: RKV
Caesar 9: QJU
Caesar 8: PIT
Caesar 7: OHS
Caesar 6: NGR
Caesar 5: MFQ
Caesar 4: LEP
Caesar 3: KDO
Caesar 2: JCN
Caesar 1: IBM
Caesar 0: HAL
	
 Encrypt and decrypt tests:
 SGHR HR Z SDRS RSQHMF EQNL ZKZM
 THIS IS A TEST STRING FROM ALAN
 UIJT JT B UFTU TUSJOH GSPN BMBO
 THIS IS A TEST STRING FROM ALAN
							
							
 1234567890!@#$%^&*(){}         
 1234567890!@#$%^&*(){}

 Solve tests:
Caesar 26: HAL
Caesar 25: GZK
Caesar 24: FYJ
Caesar 23: EXI
Caesar 22: DWH
Caesar 21: CVG
Caesar 20: BUF
Caesar 19: ATE
Caesar 18: ZSD
Caesar 17: YRC
Caesar 16: XQB
Caesar 15: WPA
Caesar 14: VOZ
Caesar 13: UNY
Caesar 12: TMX
Caesar 11: SLW
Caesar 10: RKV
Caesar 9: QJU
Caesar 8: PIT
Caesar 7: OHS
Caesar 6: NGR
Caesar 5: MFQ
Caesar 4: LEP
Caesar 3: KDO
Caesar 2: JCN
Caesar 1: IBM
Caesar 0: HAL
	
Caesar 4: LEP
Caesar 3: KDO
Caesar 2: JCN
Caesar 1: IBM
Caesar 0: HAL
\end{lstlisting}

\subsection{COBOL}
\subsubsection{My Thoughts}
Based on my experience with writing the Caesar cipher in COBOL, I have determined that it is not a user-friendly programming language in the slightest of ways. COBOL is extremely readable and self-documenting as every operation and section is explicitly defined by the programmer. This is the only decent thing going for it as the rest of my experience was dreadful due to its poor implicit type conversions and its lack of stack frames for functions.
\\ \\
First, the implicit type conversions for passing in parameters to functions was a nightmare to deal with by itself. In each function, all variables are defined with their types, and numeric types need to state the number of digits the variable will take up. However, oftentimes as a programmer you want to pass in a raw number to a function as the number will not be used anywhere else, so storing it in a variable would not be very useful. However, COBOL does not interpret these values well against defined types. For instance, an unsigned integer parameter that needs to store 2 digits must take in a number like "08" and not just "8." The main problem here is that the compiler does not say anything is wrong with the input. Instead, it can print out that it has an "8," but all mathematical operations with the value will be completely off. The same goes with signed numbers as well, but they basically do not even work as "-001" in a 3-digit signed integer comes back as "-00" and the "1" is missing, not to mention wild math results as well. Unfortunately, the only way to really deal with parameters is to pass in a variable that has the exact data type that the function is requesting. This ensures type safety as an "8" will be the same as "08," which contradicts the problems stated before. It almost reminds me of truthy and falsy values in JavaScript as you sometimes cannot tell what the output will be because the compiler just does its own thing without telling you what it is going to do.
\\ \\
Another serious issue that I faced was the lack of stack frames with function calls. In my experiences with many other programming languages, they all seem to use stack frames for function calls. That is, any variable defined in a function exists for no longer than the duration of the function. This means that the next time the function is called, the variable will be reinitialized with its starting value every time. Unfortunately, this is not the case for COBOL. Based on what I am able to tell, all variables defined in data divisions exist for the entirety of the program's lifespan. Therefore, the state of the variables for a function will be preserved across multiple function calls. COBOL lets you initialize variables in the data division with a value, but it is basically useless for functions that need to make sure that the variables get reset at the start of the function call anyway. This is another example of COBOL making itself really difficult to use because it provides functionality for features that do not make sense, at least relative to today's standards and paradigms.
\\ \\
Writing my Caesar cipher in COBOL was by far one of the most challenging things I have done as a programmer. In fact, COBOL's poor writability made Fortran look good, which demonstrates how bad my COBOL experience was because I did not originally think highly of Fortran. Although COBOL's code is self-documenting, it was nothing that could not be done with comments in Fortran and could not make up for the excruciatingly difficult task of writing COBOL code.

\subsubsection{Google Search History}
\begin{itemize}
	\item cobol hello world
	\item cobol column rules
	\item functions in cobol
	\item user-defined functions in cobol
	\item data types in cobol
	\item iterate through characters in a string cobol
	\item string copy cobol
	\item cobol function with both linkage section and working storage
	\item convert character to ascii code cobol
	\item get character from ordinal value cobol
	\item cobol addition is not right
	\item negative numbers in cobol
	\item string length cobol
	\item working storage section variables are not wiped after a function call and their state persists between function calls
\end{itemize}

\subsubsection{Code and Tests}
\lstinputlisting[caption = Caesar Cipher (COBOL), language = COBOL]{./../cobol/caesar.cbl}
\begin{lstlisting}[frame=single, caption = COBOL Output]  
> cobc -x caesar.cbl
> ./caesar
Alan tests:
BPQA QA I BMAB ABZQVO NZWU ITIV 
THIS IS A TEST STRING FROM ALAN 
Caesar +026: HAL                             
Caesar +025: GZK                             
Caesar +024: FYJ                             
Caesar +023: EXI                             
Caesar +022: DWH                             
Caesar +021: CVG                             
Caesar +020: BUF                             
Caesar +019: ATE                             
Caesar +018: ZSD                             
Caesar +017: YRC                             
Caesar +016: XQB                             
Caesar +015: WPA                             
Caesar +014: VOZ                             
Caesar +013: UNY                             
Caesar +012: TMX                             
Caesar +011: SLW                             
Caesar +010: RKV                             
Caesar +009: QJU                             
Caesar +008: PIT                             
Caesar +007: OHS                             
Caesar +006: NGR                             
Caesar +005: MFQ                             
Caesar +004: LEP                             
Caesar +003: KDO                             
Caesar +002: JCN                             
Caesar +001: IBM                             
Caesar +000: HAL                             
0
 
Encrypt and decrypt tests:
SGHR HR Z SDRS RSQHMF EQNL ZKZM 
THIS IS A TEST STRING FROM ALAN 
UIJT JT B UFTU TUSJOH GSPN BMBO 
THIS IS A TEST STRING FROM ALAN 
                                
                                
1234567890!@#$%^&*(){}          
1234567890!@#$%^&*(){}          
 
Solve tests:
Caesar +026: HAL                             
Caesar +025: GZK                             
Caesar +024: FYJ                             
Caesar +023: EXI                             
Caesar +022: DWH                             
Caesar +021: CVG                             
Caesar +020: BUF                             
Caesar +019: ATE                             
Caesar +018: ZSD                             
Caesar +017: YRC                             
Caesar +016: XQB                             
Caesar +015: WPA                             
Caesar +014: VOZ                             
Caesar +013: UNY                             
Caesar +012: TMX                             
Caesar +011: SLW                             
Caesar +010: RKV                             
Caesar +009: QJU                             
Caesar +008: PIT                             
Caesar +007: OHS                             
Caesar +006: NGR                             
Caesar +005: MFQ                             
Caesar +004: LEP                             
Caesar +003: KDO                             
Caesar +002: JCN                             
Caesar +001: IBM                             
Caesar +000: HAL                             
0
 
Caesar +004: LEP                             
Caesar +003: KDO                             
Caesar +002: JCN                             
Caesar +001: IBM                             
Caesar +000: HAL                             
0
\end{lstlisting}

\subsection{BASIC}
\subsubsection{My Thoughts}
BASIC, as implied by its name, is a very simple programming language that, at times, felt too orthogonal due to its lack of key features that are included in almost every other programming language. Despite these flaws, my experience writing the Caesar cipher in BASIC was much better than that for Fortran and COBOL.
\\ \\
User-defined program structure in BASIC was nice and flexible, but prevented any form of documentation. In BASIC, every line of code is preceded with a number that represents which line in the program the code should be inserted into. Although it was annoying to micromanage the code and make sure every line number was consistent, I did not mind this too much because I enjoy seeing these lower-level details. I was also thankful for a text editor because I know I would have struggled had I manually entered each line into an Apple II computer and rewrote the lines if I ran out of space or wanted to clean up the code organization. For subroutines, I used the practice of every 1000 lines was a new subroutine (i.e., encrypt started on line 1000, decrypt started on line 2000, and solve started on line 3000). I personally thought this was really cool because I was able to explicitly define how I wanted my code to be organized. However, calling these subroutines was through the line number, so the code was not self-documenting and comments were needed to label which subroutine was being called in each instance. This was really unfortunate as the rest of BASIC's syntax is extremely readable and self-documenting.
\\ \\
Similar to the code organization, I had mixed feelings about the simplicity of variables in BASIC. I really liked how all identifiers had to end with either a '\%' to show it is a number or a '\$' to show that it is a string. This was really nice because variable declaration was simple as the data type is implied with the name and there was never a question of a variable's type when writing the program because it is self-documented in its name. Despite this really nice syntax, BASIC provides no variable checking at runtime. For instance, if you omit the '\%' or '\$' or misspell a variable, the BASIC interpreter assumes that you are trying to reference a new variable. Thus, it creates a new variable and initializes it to 0 without telling you. When writing my Caesar cipher, this "feature" screwed up program execution, and it was very difficult to debug since there were no warnings or error messages.
\\ \\
Aside from some of these minor issues I had with BASIC, there were a few more major issues that deterred from the language's readability and writability. First, since each line of code starts with the line number in the program, there is no formatting in BASIC to line up when different blocks of code start and end. This became very challenging to debug when I forgot an endif as the code was not formatted, which hurt the language's readability and writability as well. The other serious issue with BASIC was its lack of scope for variables. All variables are global and can be accessed from anywhere in the program. This is very dangerous when dealing with subroutines and made the code quite messy when trying to reuse input and output variables that I dedicated to the various subroutines. Considering that the program is a Caesar cipher and was messy because of variable reuse, I cannot imagine writing more complex programs in BASIC and micromanaging all the variables and how and when they are used.
\\ \\
Overall, the nice syntax of BASIC made it much easier to both read and write code compared to Fortran and COBOL, the lack of formatting and variable scope makes the language much more suited for smaller programs with few moving parts as it does not scale up well with increased complexity.

\subsubsection{Google Search History}
\begin{itemize}
	\item hello world basic programming language
	\item chipmunk basic
	\item https://www.youtube.com/watch?v=7r83N3c2kPw
	\item mid\$ basic 
\end{itemize}

\subsubsection{Code and Tests}
\lstinputlisting[caption = Caesar Cipher (BASIC), language = VBScript]{./../basic/caesar.bas}
\begin{lstlisting}[frame=single, caption = BASIC Output]
Chipmunk BASIC 368b2.02
>load "/Users/joshuaseligman/Documents/GitHub/cmpt331-s23/programming-in-the-past/basic/caesar.bas
>run
Alan tests:
BPQA QA I BMAB ABZQVO NZWU ITIV
THIS IS A TEST STRING FROM ALAN
Caesar 26 : HAL
Caesar 25 : GZK
Caesar 24 : FYJ
Caesar 23 : EXI
Caesar 22 : DWH
Caesar 21 : CVG
Caesar 20 : BUF
Caesar 19 : ATE
Caesar 18 : ZSD
Caesar 17 : YRC
Caesar 16 : XQB
Caesar 15 : WPA
Caesar 14 : VOZ
Caesar 13 : UNY
Caesar 12 : TMX
Caesar 11 : SLW
Caesar 10 : RKV
Caesar 9 : QJU
Caesar 8 : PIT
Caesar 7 : OHS
Caesar 6 : NGR
Caesar 5 : MFQ
Caesar 4 : LEP
Caesar 3 : KDO
Caesar 2 : JCN
Caesar 1 : IBM
Caesar 0 : HAL

Encrypt and decrypt tests:
SGHR HR Z SDRS RSQHMF EQNL ZKZM
THIS IS A TEST STRING FROM ALAN
UIJT JT B UFTU TUSJOH GSPN BMBO
THIS IS A TEST STRING FROM ALAN


1234567890!@#$%^&*(){}
1234567890!@#$%^&*(){}

Solve tests:
Caesar 26 : HAL
Caesar 25 : GZK
Caesar 24 : FYJ
Caesar 23 : EXI
Caesar 22 : DWH
Caesar 21 : CVG
Caesar 20 : BUF
Caesar 19 : ATE
Caesar 18 : ZSD
Caesar 17 : YRC
Caesar 16 : XQB
Caesar 15 : WPA
Caesar 14 : VOZ
Caesar 13 : UNY
Caesar 12 : TMX
Caesar 11 : SLW
Caesar 10 : RKV
Caesar 9 : QJU
Caesar 8 : PIT
Caesar 7 : OHS
Caesar 6 : NGR
Caesar 5 : MFQ
Caesar 4 : LEP
Caesar 3 : KDO
Caesar 2 : JCN
Caesar 1 : IBM
Caesar 0 : HAL

Caesar 4 : LEP
Caesar 3 : KDO
Caesar 2 : JCN
Caesar 1 : IBM
Caesar 0 : HAL
\end{lstlisting}

\subsection{Pascal}
\subsubsection{My Thoughts}
My experience in Pascal was overall really good and I genuinely have very little to complain about. I found the code to be a great example of elegant simplicity. Pascal contained all of the basic programming constructs, including some of the more modern ones, while being less verbose than the other programming languages so far.
\\ \\
First, Pascal's clean and simple grammar made it both really easy to read and write the code. Some of the issues in languages like Fortran and COBOL was that they required all variables to be declared at the top of functions. Fortran did not have anything to separate these declarations and the actual program, and COBOL was extremely detailed and also did not exactly line up with the actual execution of the program. Although Pascal also requires variables to be declared at the top of functions, it has 2 very clean sections to do so, "const" for constants and "var" for everything else. The inclusion of these sections makes the code more readable as it is self-documenting within the sections as well as extremely writable as I was able to write a lot less code to do the same thing as COBOL. Another part of the language's grammar that is unique relative to the languages used so far is the walrus assignment operator (:=). Rather than using the single equal sign (=) for assignment, Pascal uses the walrus operator, which increases readability as there is no confusion between assignments and comparisons and only comes at the cost of one additional character being typed, which is a miniscule cost relative to ease of which one can understand the code.
\\ \\
Another feature that I really appreciated was how functions deal with return variables. In most other programming languages, you can return from any point in a function as well as have multiple return points. In Pascal, however, the returned variable takes the same name as the function and automatically gets returned at the end of the function. This design pattern upholds the idea of functions being one-way in and one-way out and makes the code extremely easy to understand and follow. I do, however, wish that the returned variable had a built-in name that was not the same name as the function as recursive functions may be hard to read because you can have multiple instances of the same name in a single line of code that both mean completely different things. Despite this small complaint from me, the improved design pattern carries a much larger weight than the name of a variable and, therefore, functions are much more readable and writable than most other programming languages today.
\\ \\
Overall, my experience using Pascal to write a Caesar cipher was really enjoyable due to its simple, yet feature-filled, grammar that made the code really easy to both read and write. I wish the language was more popular today because I found my experience to be better than some more modern languages that are widely used throughout the world.

\subsubsection{Google Search History}
\begin{itemize}
	\item pascal hello world
	\item pascal function multiple parameters
	\item and operator pascal boolean expression
\end{itemize}

\subsubsection{Code and Tests}
\lstinputlisting[caption = Caesar Cipher (Pascal), language = Pascal]{./../pascal/caesar.pas}
\begin{lstlisting}[frame=single, caption = Pascal Output]
> fpc caesar.pas
Free Pascal Compiler version 3.2.2 [2022/11/29] for x86_64
Copyright (c) 1993-2021 by Florian Klaempfl and others
Target OS: Darwin for x86_64
Compiling caesar.pas
Assembling caesar
Linking caesar
162 lines compiled, 0.3 sec
> ./caesar
Alan tests:
BPQA QA I BMAB ABZQVO NZWU ITIV
THIS IS A TEST STRING FROM ALAN
Caesar 26: HAL
Caesar 25: GZK
Caesar 24: FYJ
Caesar 23: EXI
Caesar 22: DWH
Caesar 21: CVG
Caesar 20: BUF
Caesar 19: ATE
Caesar 18: ZSD
Caesar 17: YRC
Caesar 16: XQB
Caesar 15: WPA
Caesar 14: VOZ
Caesar 13: UNY
Caesar 12: TMX
Caesar 11: SLW
Caesar 10: RKV
Caesar 9: QJU
Caesar 8: PIT
Caesar 7: OHS
Caesar 6: NGR
Caesar 5: MFQ
Caesar 4: LEP
Caesar 3: KDO
Caesar 2: JCN
Caesar 1: IBM
Caesar 0: HAL

Encrypt and decrypt tests:
SGHR HR Z SDRS RSQHMF EQNL ZKZM
THIS IS A TEST STRING FROM ALAN
UIJT JT B UFTU TUSJOH GSPN BMBO
THIS IS A TEST STRING FROM ALAN


1234567890!@#$%^&*(){}
1234567890!@#$%^&*(){}

Solve tests:
Caesar 26: HAL
Caesar 25: GZK
Caesar 24: FYJ
Caesar 23: EXI
Caesar 22: DWH
Caesar 21: CVG
Caesar 20: BUF
Caesar 19: ATE
Caesar 18: ZSD
Caesar 17: YRC
Caesar 16: XQB
Caesar 15: WPA
Caesar 14: VOZ
Caesar 13: UNY
Caesar 12: TMX
Caesar 11: SLW
Caesar 10: RKV
Caesar 9: QJU
Caesar 8: PIT
Caesar 7: OHS
Caesar 6: NGR
Caesar 5: MFQ
Caesar 4: LEP
Caesar 3: KDO
Caesar 2: JCN
Caesar 1: IBM
Caesar 0: HAL

Caesar 4: LEP
Caesar 3: KDO
Caesar 2: JCN
Caesar 1: IBM
Caesar 0: HAL
\end{lstlisting}

\subsection{Procedural Scala}
Scala, although very similar to Java, was a bit awkward to write in a procedural manner because its identity lies closer to a functional programming language than a procedural one. Although it tries to be a better version of Java, its increased simplicity makes the syntax feel a bit constrained and challenging to write at times.
\\ \\
First, Scala's simple syntax makes it a bit hard to both read and write in certain situations. Looping in Scala is similar to the other languages used in this assignment as it condenses the variable declaration, comparison, and post-iteration adjustment into a few words. However, the syntax is inconsistent with declaring variables everywhere else in the program, which I do not really understand. Speaking of variable declaration, Scala's syntax for declaring variables prevents one from understanding if a variable is a constant or not. Variable declaration for constants begin with "val" and variable declarations for mutable variables begin with "var." This one letter difference does not make it very readable as one can easily glance over this error (I did several times) and is not very writable because the change is so minor that I do not feel like I am expressing the purpose of a variable with a single letter.
\\ \\
Fortunately, since Scala is a newer programming language, it provides developers with a wide range of tools out of the box. More specifically, its compiler is designed to increase understanding of the problems that it finds rather than just building programs. For instance, when I was trying to assign a new value to a variable declared with "val," the compiler initially threw an unhelpful error of the problem and suggested that I use the "-explain" flag for more details. I then tried to recompile the project with the "-explain" flag and the compiler not only showed me the line of code that had the error, but also explained why it was throwing the error and how to fix it. This was extremely useful as it helped me fix the problem as well as understand what I did wrong so I could learn from my mistakes. This feature is not uncommon with compilers of newer programming languages (Rust is a great example) as it helps boost the writability of the language by providing better tools for developers to quickly get the answers to their problems rather than having to perform a Google search on an error message and hope that someone else has previously had the error.
\\ \\
Overall, Scala was not a bad programming language for the Caesar cipher as it has a lot of similar features and syntax patterns as a lot of other programming languages. However, its oversimplified syntax hurts it at times and is quickly made up for by its compiler that was built to increase developer productivity.

\subsubsection{Google Search History}
\begin{itemize}
	\item scala hello world
	\item scala loop through a string
	\item scala string object
	\item absolute value scala
	\item scala convert int to char
\end{itemize}

\subsubsection{Code and Tests}
\lstinputlisting[caption = Caesar Cipher (Scala), language = Scala]{./../scala/caesar.scala}
\begin{lstlisting}[frame=single, caption = Scala Output]  
> scalac caesar.scala -explain
> scala Caesar
Alan tests:
BPQA QA I BMAB ABZQVO NZWU ITIV
THIS IS A TEST STRING FROM ALAN
Caesar 26: HAL
Caesar 25: GZK
Caesar 24: FYJ
Caesar 23: EXI
Caesar 22: DWH
Caesar 21: CVG
Caesar 20: BUF
Caesar 19: ATE
Caesar 18: ZSD
Caesar 17: YRC
Caesar 16: XQB
Caesar 15: WPA
Caesar 14: VOZ
Caesar 13: UNY
Caesar 12: TMX
Caesar 11: SLW
Caesar 10: RKV
Caesar 9: QJU
Caesar 8: PIT
Caesar 7: OHS
Caesar 6: NGR
Caesar 5: MFQ
Caesar 4: LEP
Caesar 3: KDO
Caesar 2: JCN
Caesar 1: IBM
Caesar 0: HAL

Encrypt and decrypt tests:
SGHR HR Z SDRS RSQHMF EQNL ZKZM
THIS IS A TEST STRING FROM ALAN
UIJT JT B UFTU TUSJOH GSPN BMBO
THIS IS A TEST STRING FROM ALAN


1234567890!@#$%^&*(){}
1234567890!@#$%^&*(){}

Solve tests:
Caesar 26: HAL
Caesar 25: GZK
Caesar 24: FYJ
Caesar 23: EXI
Caesar 22: DWH
Caesar 21: CVG
Caesar 20: BUF
Caesar 19: ATE
Caesar 18: ZSD
Caesar 17: YRC
Caesar 16: XQB
Caesar 15: WPA
Caesar 14: VOZ
Caesar 13: UNY
Caesar 12: TMX
Caesar 11: SLW
Caesar 10: RKV
Caesar 9: QJU
Caesar 8: PIT
Caesar 7: OHS
Caesar 6: NGR
Caesar 5: MFQ
Caesar 4: LEP
Caesar 3: KDO
Caesar 2: JCN
Caesar 1: IBM
Caesar 0: HAL

Caesar 4: LEP
Caesar 3: KDO
Caesar 2: JCN
Caesar 1: IBM
Caesar 0: HAL
\end{lstlisting}

\section{Conclusion}
Here are my final rankings for the 5 programming languages:
\begin{enumerate}
	\item Pascal
	\item Scala
	\item BASIC
	\item Fortran
	\item COBOL
\end{enumerate}

Starting from the bottom, COBOL was a near nightmare to work with because it was extremely difficult to write and, despite its verbose code, did not follow the code that I wrote and, instead, decided to do its own thing at times. Next, Fortran was not a bad programming language by any means, but it was very difficult to write and had a compiler that produced confusing errors to understand. In second and third place, I have Scala and BASIC, respectively. Although I enjoyed writing BASIC more than Scala, the unsafe program structure of BASIC was tricky to work with at times, while the Scala compiler provided me with a great experience despite me not entirely liking its syntax. Lastly, Pascal was my favorite programming language in this assignment because it demonstrated the perfect balance of simplicity in its code while also being detailed enough for the code to document itself without me questioning what the code does.

\section{Appendix: RISC-V Assembly}
\subsection{My Thoughts}
For an additional challenge (and some fun), I decided to also complete the assignment in RISC-V assembly. Since the solution in the other programming languages was quite simple, the logic of the RISC-V assembly was very similar and was easy to translate from the other languages. I was genuinely surprised by the writability of RISC-V assembly, but this increased writability hurts the readability from the short instructions.
\\ \\
RISC-V was surprisingly extremely expressive for a an assembly language. RISC-V is unique in that it has a very small instruction set with not many features. However, it comes with a collection of pseudo instructions that all translate more common instructions in other assembly languages into the RISC-V equivalent. For instance, instead of loading a constant to a register by doing "ADDI rd, zero, immediate," RISC-V has a pseudo instruction of LI, which stands for load immediate and just takes in the destination register and the immediate. This expressiveness made it easier to write as the pseudo instruction is a mini higher-level abstraction that allowed me to focus on the logic and register management rather than dealing with any small nuances with RISC-V assembly. Additionally, the small instruction set made it quick to learn as I was able to build the entire program with only a small number of instructions. Next, the program structure of the RISC-V implementation reminded me the most of BASIC as it was just one big program and I had to manage the different subroutines that get run and the registers that are needed in each subroutine. However, one of the features of RISC-V that BASIC was lacking was a stack pointer. With this capability, I was able to modularize my code and not worry about a subroutine overwriting a register that was being used in a different subroutine.
\\ \\
Despite the impressive writability of RISC-V assembly, the terse instructions made the RISC-V assembly difficult to read. Since instructions are typically 2-4 letters long, I always felt that I was not being verbose enough to be able to understand the code that I wrote. Thus, comments were a necessity to explain what each chunk of code did so I could look back and understand the logic behind the various subroutines. Assembly is already hard enough to read because of its extreme low-level nature, so the very short instructions never helped with being able to read the code because I had to think to myself what each instruction represented.
\\ \\
Overall, I really enjoyed writing the Caesar cipher in RISC-V assembly and found it easier than Fortran and COBOL. However, assembly is not a reasonable choice for complex programs as one has to manage all of the registers by hand and micromanage every tiny detail of the program. Regardless, I believe that RISC-V assembly is a really nice way to better understand both computer hardware as well as compilers and how they manage registers and the various resources in a computer.

\subsection{Resources I Used}
As RISC-V assembly was purely for my own enjoyment, I did not time myself or keep track of my Google Search history. Instead, I did keep track of some of the most useful resources I found.
\begin{itemize}
	\item Toolchain (Homebrew): https://github.com/riscv-software-src/homebrew-riscv
	\item RISC-V hello world (one of my favorite youtube channels for CS): https://www.youtube.com/watch?v=GWiAQs4-UQ0	
	\item Instruction cheat sheet: http://blog.translusion.com/images/posts/RISC-V-cheatsheet-RV32I-4-3.pdf
	\item Stack and functions: http://wla.berkeley.edu/~cs61c/fa17/lec/06/L06\%20RISCV\%20Functions\%20(1up).pdf
	\item Linux system calls: https://github.com/riscv-collab/riscv-gnu-toolchain/blob/master/linux-headers/include/asm-generic/unistd.h
	\item RISC-V book: https://riscv-programming.org/book/riscv-book.html
\end{itemize}

\subsection{Code and Tests}
\lstinputlisting[caption = Caesar Cipher (RISC-V Assembly)]{./../riscv/caesar.s}
\begin{lstlisting}[frame=single, caption = RISC-V Assembly Output]  
> make
rm -f caesar.o
rm -f caesar
riscv64-unknown-elf-as -g -c caesar.s -o caesar.o
riscv64-unknown-elf-gcc -g caesar.o -o caesar -nostdlib -static
> make run
riscv64-unknown-elf-run caesar
BPQA QA I BMAB ABZQVO NZWU ITIV
THIS IS A TEST STRING FROM ALAN
HAL
GZK
FYJ
EXI
DWH
CVG
BUF
ATE
ZSD
YRC
XQB
WPA
VOZ
UNY
TMX
SLW
RKV
QJU
PIT
OHS
NGR
MFQ
LEP
KDO
JCN
IBM
HAL

SGHR HR Z SDRS RSQHMF EQNL ZKZM
THIS IS A TEST STRING FROM ALAN
UIJT JT B UFTU TUSJOH GSPN BMBO
THIS IS A TEST STRING FROM ALAN


1234567890!@#$%^&*(){}
1234567890!@#$%^&*(){}

HAL
GZK
FYJ
EXI
DWH
CVG
BUF
ATE
ZSD
YRC
XQB
WPA
VOZ
UNY
TMX
SLW
RKV
QJU
PIT
OHS
NGR
MFQ
LEP
KDO
JCN
IBM
HAL

LEP
KDO
JCN
IBM
HAL
\end{lstlisting}

\end{document}