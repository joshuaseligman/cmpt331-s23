\documentclass[letterpaper, 10pt, DIV=13]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath, amsfonts, amsthm, xfrac}
\usepackage{listings}
\usepackage{color}
\usepackage{longtable}

\numberwithin{equation}{section}
\numberwithin{figure}{section}
\numberwithin{table}{section}

\usepackage{sectsty}
\allsectionsfont{\normalfont\scshape} % Make all section titles in default font and small caps.

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers

\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer

\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt}

% Colors and lstset for syntax highlighting from https://www.overleaf.com/latex/examples/syntax-highlighting-in-latex-with-the-listings-package/jxnppmxxvsvk
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}

\setlength\parindent{0pt}
\pagenumbering{gobble}

\title {
	\normalfont
	\huge{Functional Programming} \\
	\vspace{10pt}
	\large{CMPT 331 - Spring 2023 | Dr. Labouseur}
}

\author{\normalfont Josh Seligman | joshua.seligman1@marist.edu}
\date{\normalfont April 21, 2023}

\pagenumbering{arabic}
\begin{document}
\maketitle

\section{Log}
\subsection{Predicton}
I am predicting that it will take me around \textbf{15 hours (average of 3 hours per programming language)} for me to learn LISP, ML, Erlang, 
functional JavaScipt, and functional Scala and write a Caesar cipher in each langage. Although I know that some of this assignment will be more 
challenging than Programming in the Past because functional programming requires a completely different mindset, I am already familiar with 
functional JavaScipt and can use some of that knowledge to hopefully be able to quickly write the Caesar cipher in each language. Also, since I 
have already written the Caesar cipher in 5 languages, I know this assignment will be translating that work into a functional manner rather than 
trying to do it entirely from scratch. 

\subsection{Progress Log}
\begin{center}
	\begin{longtable}{|p{1in}|p{1in}|p{4in}|}
		\hline
		Date & Hours Spent & Tasks / Accomplishments / Issues / Thoughts
		\\
		\hline
        March 6 & 3.5 hours & I wrote the Caesar cipher in LISP. It was a bit challenging because the syntax is not the cleanest and it is very 
        difficult to find things online about it because every dialect does basic tasks different from one another.
        \\
		\hline
        March 7 & 3.5 hours & I wrote the Caesar cipher in ML. It wos better documented than LISP, but more challenging to write because of its 
        steeper learning curve.
        \\
        \hline
        March 8 & 0.25 hours & I had a lightbulb moment regarding everything I did poorly in ML and fixed it all up. I am much happier now that the code is
        more concise and flows a lot better.
        \\
        \hline
        March 8 & 2.5 hours & I wrote the Caesar cipher in Erlang and was pleasantly surprised by how easy it was relative to LISP and ML.
        \\
        \hline
	\end{longtable}
\end{center}

\subsection{Final Results and Analysis}

\section{Commentary}
\subsection{LISP}
\subsubsection{My Thoughts}
LISP was a language I do not want to remember because it was nothing special relative to most other programming languages and had some features 
that were really frustrating to deal with. More specifically, the syntax for the language is too simplistic with intense operator overloading, 
confusing code organization, and poor online resources.
\\ \\
First, the syntax of LISP is extremely simple because parentheses are used everywhere. In LISP, lists are the main data structure and are denoted with 
parentheses. However, lists are used to make function calls, to define functions, and to store data, which makes it really confusing what is being stored within a 
list as there is nothing to differentiate these structures. Readability is seriously hurt from this as I still struggle to make the distinction between function 
calls and data after writing the code. Additionally, I found it difficult to write LISP code because the parentheses were challenging to manage and to keep clean. 
I tried my absolute best to keep parentheses lined up similar to how braces would be lined up in C family languages, but it still was not perfect and had some 
inconsistencies. Furthermore, messing up on the parentheses was a pain to debug because the LISP interpreter would throw a confusing error that meant absolutely 
nothing in helping me resolve the real problem.
\\ \\
Next, LISP has a very frustrating way to represent math operations. Since everything is a function in LISP, all math functions will take in 2 arguments, which 
can be the result of other math function calls. Similar to how a compiler works, the operations you want to do first have to be encapsulated so their output 
will be used by other functions. Hovever, I had to learn this idea the hard way when I did (- 90 (+ diff 1) instead of (+ (- 90 diff) 1)) to represent the formula
90 - diff + 1. Naturally, I wanted to represent the subtraction first, so I naively placed it in the outermost function call, which was a really bad idea.
Although minor, this change in operation order screwed up my program for a while and my friends had to remind me of the order of operations for why the 2 
code chunks weere different from each other. This syntax for specifying the order of operations for a formula does not make logical sense as the code no 
longer reads from left to right. Rather, one has to read it middle out (sadly not related to middle out compression in the TV show Silicon Valley) and do a depth-first
in-order traversal of a mini syntax tree in their head to be able to actually understand what the code is doing. This amount of brain damage is completely overkill as
one already has to treat functional logic completely differently from procedural logic, and this math function ordering does not help LISP in being user-friendly.
\\ \\
Lastly, LISP is a really old language, and, similar to BASIC, its many dialects made good online resources hard to come by. When searching for how to do something in LISP, 
whatever a website had as an answer was most likely wrong becouse the dialect that I was using (newLISP) did not support functionalities specific to some of the 
other dialects. Unfortunately, no website specified what dialect they were referring to, and doing the same search but with "newLISP" instead of "lisp" would 
just bring up the documentation for newLISP. At the end of the day, this documentation and the corresponding Wikibook were my best friends for writing the Caesar cipher
in LISP as they provided me with the basics to get started, which I was able to modify for my own purposes.
\\ \\
Overall, LISP was not a terrible programming language as I really liked the succinctness of its functional style, but its overly simplistic syntax, annoying math 
functions, and limited resources made it challenging to work with. Relative to the Programming in the Past assignment, I would rank LISP similar to Fortran as they are 
both the grandfather languages of their respective domains and were not terrible and somewhat useable, but I would never want to use them again if I do not have to.

\subsubsection{Google Search History}
\begin{itemize}
    \item lisp hello world (https://en.wikibooks.org/wiki/Introduction\_to\_newLISP)
    \item comments in lisp
    \item math functions lisp
    \item lambda in lisp
    \item and in lisp
\end{itemize}

\subsubsection{Code and Tests}
\lstinputlisting[caption = Caesar Cipher (LISP), language = LISP]{./../lisp/caesar.lsp}
\lstinputlisting[caption = LISP Output]{./../lisp/caesar.txt}

\subsection{ML}
\subsubsection{My Thoughts}
My Caesar cipher in ML will forever be remembered as the hackiest solution to a Caesar cipher. The language itself is just a cleaned up version of LISP with better
documentation, but lack of sequential statements within functions and some weird math quirks made it one of the most rewarding challenges I have had in recent memory.
\\ \\
From my knowledge, ML functions do not support chaining multiple statements together. Rather, they only support returning the output from a single function call,
which can have many nested function calls used as the input to the main function whose value is being returned. This made modularization difficult because it was
always a big dilemma as to which chunks of logic could be put together versus separating them out into their own functions. As a fan of procedural programming,
this was difficult to wrap my brain around as I struggled to match the data types together to be able to use the output from one function as the input to another.
Furthermore, as an inexperienced functional programmer, I initially forced together a solution that worked but was very inefficient as I made a list of shift amounts
and then ziped that list with the characters to create a list of tuples to pass into the performShift function. It was not until after a good night's rest when I realized
that I could have just used an anonymous function and only map through the characters because then I could pass the shift amount in consistently without my crazy 
solution. Although my initial solution worked, I did make the change for code conciseness and because it was a better translation of the logic that was being done.
This was also a lesson learned as the first solution that comes to mind when writing a functional program is not always the best answer because the logic has to be
thought of in a more abstract way to come up with the best possible solution.
\\ \\
The other weird quirk was the syntax for negative numbers. When I was initially writing my ML program, I did not know how to represent a negative number in ML.
Every time I wanted to use a - to represent negation, I was presented with a syntax error, most likely because - was a function for subtraction behind the scenes.
Since I was already in the mindset to hack a solution together, I put a Band Aid on the problem by writing a function that negated a number by subtracting itself
twice. I originally did not care about this function because it worked, but it did bother me because I knew that there was no way a programming language would
make me write a negate function just to be able to represent a negative number. Similar to the previous problem with the hacky map function, I played around in 
ML's interactive mode for a couple minutes the next day to find out that it uses $\sim$ instead of - to represent negative values. Although this is a tiny quirk of ML, 
it really bothered me because the writability was harmed due to the language not able to fully represent standand mathematical notation. Fortunately, this did not 
cause me nearly as much brain dammage as the order of operations in LISP or trying to force multiple arguments into a map function in ML, but it was something to note
because it was initially a key part in my program until I fixed it for clarity in the code.
\\ \\
Despite my annoyed experience writing the Caesar cipher in ML, I did have some good moments writing it. First, I love the type safety of the language as every
variable and function is strictly defined. This is crucial for functional languages because it makes the code self-documenting and I know exactly what data type
a function expects and what I will be receiving back as a return value. My other positive note was specific to the Standard ML of New Jersey, but its interactive
mode proved to be extremely useful when I was trying to figure out what functions were available to me. For instance, if I typed the command "open String;", I was 
presented with a full list of every string function in ML with definitions for the expected data types of the arguments and the return type. I did not dive deeper to
find formal function definitions with verbose descriptions of what a given function did, but the basic definitions were enough for me as I was able to find
what I was looking for and quickly added it to my code.
\\ \\
ML is in a weird place for me because it was more challenging than LISP because of the lack of sequential statements within a function, but I preferred its syntax and
tooling over LISP. In other words, although my experience in LISP was better than ML, I would pick ML over LISP if I had to write a program in a functional language
because its sytax is cleaner and significantly more readable and has better tooling and documentation compared to LISP.

\subsubsection{Google Search History}
\begin{itemize}
    \item standard ml of nj (https://www.smlnj.org/doc/literature.html\#tutorials)
    \item ML programming language hello world (https://www.cs.nmsu.edu/$\sim$rth/cs/cs471/sml.html) (Amazing resource)
    \item sml merge 2 lists into a list of tuples (https://cs.wellesley.edu/$\sim$cs251/s19/slides/sml-lists-solns\_4up.pdf) (Another great resource)
    \item else if sml
\end{itemize}

\subsubsection{Code and Tests}
\lstinputlisting[caption = Caesar Cipher (ML), language = ML]{./../ml/caesar.sml}
\lstinputlisting[caption = ML Output]{./../ml/caesar.txt}

\subsection{Erlang}
\subsubsection{My Thoughts}
Erlang was a language that I was not expecting to like, but I really enjoyed my time working in Erlang. The langugae does come with a some problems,
such as it not being strongly typed and performs implicit type conversions and variables are all immutable, but the syntax is overall really clean and easy to follow.
\\ \\
My only serious issue with Erlang was the implicit type conversion from a string to an integer. Erlang does not support strings and, instead, treats
a string as a list of characters, which are just numbers behind the scenes. Thus, when I wrote the performShift method, I passed in the string/list
and it automatically treated the data as an integer instead of a character. This is extremely dangerous because I never told it to make the conversion
and was expecting to see individual characters. Unfortunately, this problem is emphasized more because Erlang is not strongly typed, so I never had an
opportunity to state what data type I wanted each variable to be. This hurts Erlang in all 3 aspects: readability, writability, and reliability because
the code is not self-documenting, it is harder to write when the variables are not strongly typed, and the language cannot be reliable if it does not tell
the programmer that it is doing its own thing by making the conversions on its own.
\\ \\
One minor issue I had with Erlang was that all variables are immutable. Since Erlang supports sequential statements, I assumed that I would be able
to combine a few statements to help create the logic for determining the value of a returned variable. Unfortunately, since variables are immutable, I had to
be a little creative for how I could assign the proper value in one statement compared to in multiple steps. This is an extremely minor complaint on my
part as it did not seriously impact my experience with Erlang.
\\ \\
Aside from the issues with the type conversions, Erlang's syntax is extremely clean and very easy to follow. I also appreciated how everything in Erlang 
requires recursion. When writing the Caesar cipher in LISP and ML, I was extremely caught up in the notion of using the map functionality to call a function 
many times and feel that I did not use recursion enough for those solutions. Erlang forces you to use recursion for literally everything as the functions to
loop through the string and the solve shift amounts were done via recursion. Recursion is extremely easy to read, and the writability is stronger for Erlang 
for the consistency and minimal feature multiplicity with recursion being the way. This is the way, the Erlang way.
\\ \\
Overall, Erlang was actually really fun to use. Its syntax was really easy to learn, which helped me quickly and efficiently write my Caesar cipher.
Despite the weird type conversions, Erlang is at least consistent about its weirdness and does not do anything unexpected once you start to learn
how the language really works. The best part of Erlang was undoubtedly all of the recursion and how easy it was to be able to implement this form of logic
within the program.

\subsubsection{Google Search History}
\begin{itemize}
    \item https://www.tutorialspoint.com/erlang/ (From Alan's Language Study page)
    \item strings in erlang
    \item map function over list erlang (https://www.erlang.org/doc/programming\_examples/funs.html)
    \item erlang if statement
    \item and in erlang
    \item modulo in erlang
    \item erlang empty true statement in if statement
\end{itemize}

\subsubsection{Code and Tests}
\lstinputlisting[caption = Caesar Cipher (Erlang), language = Erlang]{./../erlang/caesar.erl}
\lstinputlisting[caption = Erlang Output]{./../erlang/caesar.txt}

\subsection{Functional JavaScipt}
\subsubsection{My Thoughts}

\subsubsection{Google Search History}
%\begin{itemize}
%\end{itemize}

\subsubsection{Code and Tests}

\subsection{Functional Scala}

\subsubsection{Google Search History}
%\begin{itemize}
%\end{itemize}

\subsubsection{Code and Tests}

\end{document}
