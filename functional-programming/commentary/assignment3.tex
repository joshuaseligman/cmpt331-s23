\documentclass[letterpaper, 10pt, DIV=13]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath, amsfonts, amsthm, xfrac}
\usepackage{listings}
\usepackage{color}
\usepackage{longtable}

\numberwithin{equation}{section}
\numberwithin{figure}{section}
\numberwithin{table}{section}

\usepackage{sectsty}
\allsectionsfont{\normalfont\scshape} % Make all section titles in default font and small caps.

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers

\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer

\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt}

% Colors and lstset for syntax highlighting from https://www.overleaf.com/latex/examples/syntax-highlighting-in-latex-with-the-listings-package/jxnppmxxvsvk
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}

\setlength\parindent{0pt}
\pagenumbering{gobble}

\title {
	\normalfont
	\huge{Functional Programming} \\
	\vspace{10pt}
	\large{CMPT 331 - Spring 2023 | Dr. Labouseur}
}

\author{\normalfont Josh Seligman | joshua.seligman1@marist.edu}
\date{\normalfont April 21, 2023}

\pagenumbering{arabic}
\begin{document}
\maketitle

\section{Log}
\subsection{Predicton}
I am predicting that it will take me around \textbf{15 hours (average of 3 hours per programming language)} for me to learn LISP, ML, Erlang, 
functional JavaScipt, and functional Scala and write a Caesar cipher in each langage. Although I know that some of this assignment will be more 
challenging than Programming in the Past because functional programming requires a completely different mindset, I am already familiar with 
functional JavaScipt and can use some of that knowledge to hopefully be able to quickly write the Caesar cipher in each language. Also, since I 
have already written the Caesar cipher in 5 languages, I know this assignment will be translating that work into a functional manner rather than 
trying to do it entirely from scratch. 

\subsection{Progress Log}
\begin{center}
	\begin{longtable}{|p{1in}|p{1in}|p{4in}|}
		\hline
		Date & Hours Spent & Tasks / Accomplishments / Issues / Thoughts
		\\
		\hline
        March 6 & 3.5 hours & I wrote the Caesar cipher in LISP. It was a bit challenging because the syntax is not the cleanest and it is very 
        difficult to find things online about it because every dialect does basic tasks different from one another.
        \\
		\hline
        March 7 & 3.5 hours & I wrote the Caesar cipher in ML. It wos better documented than LISP, but more challenging to write because of its 
        steeper learning curve.
        \\
        \hline
	\end{longtable}
\end{center}

\subsection{Final Results and Analysis}

\section{Commentary}
\subsection{LISP}
\subsubsection{My Thoughts}
LISP was a language I do not want to remember because it was nothing special relative to most other programming languages and had some features 
that were really frustrating to deal with. More specifically, the syntax for the language is too simplistic with intense operator overloading, 
confusing code organization, and poor online resources.
\\ \\
First, the syntax of LISP is extremely simple because parentheses are used everywhere. In LISP, lists are the main data structure and are denoted with 
parentheses. However, lists are used to make function calls, to define functions, and to store data, which makes it really confusing what is being stored within a 
list as there is nothing to differentiate these structures. Readability is seriously hurt from this as I still struggle to make the distinction between function 
calls and data after writing the code. Additionally, I found it difficult to write LISP code because the parentheses were challenging to manage and to keep clean. 
I tried my absolute best to keep parentheses lined up similar to how braces would be lined up in C family languages, but it still was not perfect and had some 
inconsistencies. Furthermore, messing up on the parentheses was a pain to debug because the LISP interpreter would throw a confusing error that meant absolutely 
nothing in helping me resolve the real problem.
\\ \\
Next, LISP has a very frustrating way to represent math operations. Since everything is a function in LISP, all math functions will take in 2 arguments, which 
can be the result of other math function calls. Similar to how a compiler works, the operations you want to do first have to be encapsulated so their output 
will be used by other functions. Hovever, I had to learn this idea the hard way when I did (- 90 (+ diff 1) instead of (+ (- 90 diff) 1)) to represent the formula
90 - diff + 1. Naturally, I wanted to represent the subtraction first, so I naively placed it in the outermost function call, which was a really bad idea.
Although minor, this change in operation order screwed up my program for a while and my friends had to remind me of the order of operations for why the 2 
code chunks weere different from each other. This syntax for specifying the order of operations for a formula does not make logical sense as the code no 
longer reads from left to right. Rather, one has to read it middle out (sadly not related to middle out compression in the TV show Silicon Valley) and do a depth-first
in-order traversal of a mini syntax tree in their head to be able to actually understand what the code is doing. This amount of brain damage is completely overkill as
one already has to treat functional logic completely differently from procedural logic, and this math function ordering does not help LISP in being user-friendly.
\\ \\
Lastly, LISP is a really old language, and, similar to BASIC, its many dialects made good online resources hard to come by. When searching for how to do something in LISP, 
whatever a website had as an answer was most likely wrong becouse the dialect that I was using (newLISP) did not support functionalities specific to some of the 
other dialects. Unfortunately, no website specified what dialect they were referring to, and doing the same search but with "newLISP" instead of "lisp" would 
just bring up the documentation for newLISP. At the end of the day, this documentation and the corresponding Wikibook were my best friends for writing the Caesar cipher
in LISP as they provided me with the basics to get started, which I was able to modify for my own purposes.
\\ \\
Overall, LISP was not a terrible programming language as I really liked the succinctness of its functional style, but its overly simplistic syntax, annoying math 
functions, and limited resources made it challenging to work with. Relative to the Programming in the Past assignment, I would rank LISP similar to Fortran as they are 
both the grandfather languages of their respective domains and were not terrible and somewhat useable, but I would never want to use them again if I do not have to.

\subsubsection{Google Search History}
\begin{itemize}
    \item lisp hello world (https://en.wikibooks.org/wiki/Introduction\_to\_newLISP)
    \item comments in lisp
    \item math functions lisp
    \item lambda in lisp
    \item and in lisp
\end{itemize}

\subsubsection{Code and Tests}
\lstinputlisting[caption = Caesar Cipher (LISP), language = LISP]{./../lisp/caesar.lsp}
\lstinputlisting[caption = LISP Output]{./../lisp/caesar.txt}

\subsection{ML}
\subsubsection{My Thoughts}

\subsubsection{Google Search History}
\begin{itemize}
    \item standard ml of nj (https://www.smlnj.org/doc/literature.html\#tutorials)
    \item ML programming language hello world (https://www.cs.nmsu.edu/$\sim$rth/cs/cs471/sml.html) (AMAZING resource)
    \item sml merge 2 lists into a list of tuples (https://cs.wellesley.edu/$\sim$cs251/s19/slides/sml-lists-solns\_4up.pdf) (Another great resource)
    \item else if sml
\end{itemize}

\subsubsection{Code and Tests}
\lstinputlisting[caption = Caesar Cipher (ML), language = ML]{./../ml/caesar.sml}
\lstinputlisting[caption = ML Output]{./../ml/caesar.txt}

\subsection{Erlang}
\subsubsection{My Thoughts}

\subsubsection{Google Search History}
%\begin{itemize}
%\end{itemize}

\subsubsection{Code and Tests}

\subsection{Functional JavaScipt}
\subsubsection{My Thoughts}

\subsubsection{Google Search History}
%\begin{itemize}
%\end{itemize}

\subsubsection{Code and Tests}

\subsection{Functional Scala}

\subsubsection{Google Search History}
%\begin{itemize}
%\end{itemize}

\subsubsection{Code and Tests}

\end{document}
